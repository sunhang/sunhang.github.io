<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>编程语言的容器的学习</title></head><body>　　<div class="inner"><h2>编程语言的容器的学习</h2><h1 id="C-的容器"><a href="#C-的容器" class="headerlink" title="C++的容器"></a>C++的容器</h1><p>最近在做一些leetcode的题，有时选择了用C++来写，离不开一些C++容器的使用。于是总结一下C++容器。</p>
<h2 id="顺序性容器"><a href="#顺序性容器" class="headerlink" title="顺序性容器"></a>顺序性容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ol>
<li>vector是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢。</li>
<li>默认的构造函数是构造一个初始长度为0的内存空间，且分配的内存空间是以2的倍数动态增长的。</li>
<li>在push_back的过程中，若发现分配的内存空间不足，则重新分配一段连续的内存空间，其大小是现在连续空间的2倍，再将原先空间中的元素复制到新的空间中。</li>
<li>clear函数只是把vector的size清为零，但vector中的元素在内存中并没有消除，所以在使用vector的过程中会发现内存消耗会越来越多，导致内存泄露，现在经常用的方法是swap函数来进行解决。</li>
<li>利用swap函数，和临时对象交换，使V对象的内存为临时对象的内存，而临时对象的内存为V对象的内存。交换以后，临时对象消失，释放内存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V;</span><br><span class="line">V.push_back(<span class="number">1</span>); </span><br><span class="line">V.push_back(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(V); </span><br><span class="line"><span class="comment">//或者 V.swap(vector&lt;int&gt;());</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque支持双端插入数据。deque的内存空间分布是小片的连续，小片间用链表相连，实际上内部有一个map的指针。deque空间的重新分配要比vector快，重新分配空间后，原有的元素是不需要拷贝的。</p>
<p><img src="/images/my/container/00.png" alt=""></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>支持常数时间从容器任何位置插入和移除元素的容器。不支持快速随机访问。它通常实现为双向链表。</p>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map是一种关联容器，该容器用唯一的关键字来映射相应的值，即具有key-value功能。map内部自建一棵红黑树（一种自平衡二叉树），这棵树具有数据自动排序的功能，所以在map内部所有的数据都是有序的，以二叉树的形式进行组织。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ol>
<li>set同map一样，底层使用红黑树实现，插入删除操作时仅仅移动指针即可，不涉及内存的移动和拷贝，所以效率比较高。</li>
<li>set中的元素都是唯一的，而且默认情况下会对元素进行升序排列。</li>
</ol>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue是一个队列，实现先进先出功能。queue是在deque的基础上封装的。</p>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack是实现先进后出的功能，和queue一样，也是内部封装了deque。</p>
<h1 id="java的容器"><a href="#java的容器" class="headerlink" title="java的容器"></a>java的容器</h1><p>第一个图为简化图（其中粗线部分是重点的容器），第二个图为完整容器分类图</p>
<p><img src="/images/my/container/01.png" alt=""></p>
<p><img src="/images/my/container/02.png" alt=""></p>
<p><img src="/images/my/container/03.png" alt=""></p>
<h1 id="java的容器和kotlin容器的比较"><a href="#java的容器和kotlin容器的比较" class="headerlink" title="java的容器和kotlin容器的比较"></a>java的容器和kotlin容器的比较</h1><p><img src="/images/my/container/04.png" alt=""></p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>