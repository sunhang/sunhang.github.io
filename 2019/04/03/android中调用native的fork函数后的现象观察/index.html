<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>android中调用native的fork函数后的现象观察</title></head><body>　　<div class="inner"><h2>android中调用native的fork函数后的现象观察</h2><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>android的app运行过程中，如果通过jni调用到了native层的fork()函数，那么java层的各对象都会复制一份吗？</p>
<h3 id="建工程做实验"><a href="#建工程做实验" class="headerlink" title="建工程做实验"></a>建工程做实验</h3><p>建立一个包含C++的android工程，在工程中的native-lib.cpp中改成这个<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jint JNICALL</span><br><span class="line">Java_mainpackage_MainActivity_invokeFork(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在kotlin中建立一个class<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainpackage</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeBody</span></span>(<span class="keyword">var</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(<span class="variable">$name</span> <span class="subst">$&#123;System.identityHashCode(this).toHex()&#125;</span>)"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">toHex</span><span class="params">()</span></span> = Integer.toHexString(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在MainActivity中写一个函数<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">studyFork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = SomeBody(<span class="string">"张三"</span>)</span><br><span class="line">    Log.i(<span class="string">"fork"</span>, <span class="string">"before fork &gt;&gt; sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span> forkRet = invokeFork()</span><br><span class="line">    Log.i(<span class="string">"fork"</span>, <span class="string">"after fork &gt;&gt; forkRet: <span class="variable">$forkRet</span> pid: <span class="subst">$&#123;Process.myPid()&#125;</span> sb: <span class="variable">$sb</span>"</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且在MainActivity被create之后，调用<code>studyFork()</code><br>发现输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before fork &gt;&gt; sb: (张三 3e8825b)</span><br><span class="line">after fork &gt;&gt; forkRet: 21281 pid: 21262 sb: (张三 3e8825b)</span><br><span class="line">after fork &gt;&gt; forkRet: 0 pid: 21281 sb: (张三 3e8825b)</span><br></pre></td></tr></table></figure></p>
<p>观察结果，得出自己的判断，对象sb在主进程和子进程中是同一个，即主进程和子进程共享同一个对象（后面的实验推翻了这个结论）。</p>
<h3 id="新的困惑"><a href="#新的困惑" class="headerlink" title="新的困惑"></a>新的困惑</h3><p>主进程和子进程共享虚拟机中同一个堆空间吗？两个进程操作这个对象，观察到的结果是什么呢？<br>继续做实验，修改了<code>studyFork()</code>函数如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">studyFork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = SomeBody(<span class="string">"张三"</span>)</span><br><span class="line"></span><br><span class="line">    Log.i(<span class="string">"fork"</span>, <span class="string">"before fork &gt;&gt; sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span> forkRet = invokeFork()</span><br><span class="line">    Log.i(<span class="string">"fork"</span>, <span class="string">"after fork &gt;&gt; forkRet: <span class="variable">$forkRet</span> pid: <span class="subst">$&#123;Process.myPid()&#125;</span> sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forkRet == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        sb.name = <span class="string">"李四"</span></span><br><span class="line">        Log.i(<span class="string">"fork"</span>, <span class="string">"sub process &gt;&gt; forRet: <span class="variable">$forkRet</span> modified-sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        Log.i(<span class="string">"fork"</span>, <span class="string">"parent process &gt;&gt; forRet: <span class="variable">$forkRet</span> sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让子进程创建后立刻修改sb的name为“李四”，然后父进程1s之后观察这个sb并打印日志。日志如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-04-03 18:33:24.208  I/fork: before fork &gt;&gt; sb: (张三 3e8825b)</span><br><span class="line">2019-04-03 18:33:24.214  I/fork: after fork &gt;&gt; forkRet: 0 pid: 22143 sb: (张三 3e8825b)</span><br><span class="line">2019-04-03 18:33:24.214  I/fork: after fork &gt;&gt; forkRet: 22143 pid: 22123 sb: (张三 3e8825b)</span><br><span class="line">2019-04-03 18:33:24.215  I/fork: sub process &gt;&gt; forRet: 0 modified-sb: (李四 3e8825b)</span><br><span class="line">2019-04-03 18:33:25.219  I/fork: parent process &gt;&gt; forRet: 22143 sb: (张三 3e8825b)</span><br></pre></td></tr></table></figure></p>
<p>于是得出自己的判断：子进程修改了sb对象的name，主进程感知不到。进而得出这样的结论，主进程和子进程不共享同一个对象，只是各自持有一份sb拷贝。进而，两个进程不共享虚拟机的同一个堆空间。</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>