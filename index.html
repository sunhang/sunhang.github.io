<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>程序员孙航</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="程序员孙航">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="程序员孙航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员孙航">
  
    <link rel="alternate" href="/atom.xml" title="程序员孙航" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">程序员孙航</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">乐在行走</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-关于android异步编程的学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/15/关于android异步编程的学习/" class="article-date">
  <time datetime="2020-01-15T13:58:35.000Z" itemprop="datePublished">2020-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/15/关于android异步编程的学习/">关于android异步编程的学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h1><h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><h3 id="什么是thread"><a href="#什么是thread" class="headerlink" title="什么是thread"></a>什么是thread</h3><h2 id="thread-pool"><a href="#thread-pool" class="headerlink" title="thread-pool"></a>thread-pool</h2><h1 id="java8的CompletableFuture"><a href="#java8的CompletableFuture" class="headerlink" title="java8的CompletableFuture"></a>java8的CompletableFuture</h1><h1 id="rxjava"><a href="#rxjava" class="headerlink" title="rxjava"></a>rxjava</h1><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/2d2e21941461" target="_blank" rel="noopener">https://www.jianshu.com/p/2d2e21941461</a><br><a href="https://www.jianshu.com/p/06703abc56b1" target="_blank" rel="noopener">https://www.jianshu.com/p/06703abc56b1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/15/关于android异步编程的学习/" data-id="ck5fynb72003nhes64ln2uezz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于kotlin的几个扩展函数-run-apply-let-with-also" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/15/关于kotlin的几个扩展函数-run-apply-let-with-also/" class="article-date">
  <time datetime="2020-01-15T13:50:41.000Z" itemprop="datePublished">2020-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/15/关于kotlin的几个扩展函数-run-apply-let-with-also/">关于kotlin的几个扩展函数(run, apply, let, with, also)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="run"><a href="#run" class="headerlink" title="run"></a>run</h1><p>run：执行的意思。一个实例要去run了。比如说：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> boar = people.run &#123;</span><br><span class="line">    goHunting(); <span class="comment">// 打猎</span></span><br><span class="line">    fight(); <span class="comment">// 战斗</span></span><br><span class="line">    catchAWildBoar(); <span class="comment">//抓到一只野猪</span></span><br><span class="line">&#125; <span class="comment">// run返回野猪</span></span><br></pre></td></tr></table></figure></p>
<p>返回这个人运行后结果。即，打猎、战斗后，抓到了一只野猪。</p>
<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p>apply：有道词典翻译的是申请、应用的意思。一个实例要去应用了。比如说：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> richboy = Girl().apply &#123;</span><br><span class="line">    getDressed() <span class="comment">// 穿衣服</span></span><br><span class="line">    makeUp() <span class="comment">// 化妆</span></span><br><span class="line">&#125;.run &#123; <span class="comment">// apply返回女孩这个实例</span></span><br><span class="line">    attendDancingParty() <span class="comment">// 参加一个舞会</span></span><br><span class="line">    catchARichBoy() <span class="comment">// 钓到金龟婿</span></span><br><span class="line">&#125; <span class="comment">// run返回金龟婿</span></span><br></pre></td></tr></table></figure></p>
<p>这个女孩通过一系列应用（穿衣打扮），然后去运行了（参加舞会钓到金龟婿）。最后把金龟婿赋值给richboy。</p>
<p>对于apply的应用场景，有时是为了编程图方便，流畅。比如说：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> girl = Girl().apply &#123; getDressed() &#125; <span class="comment">// 构造实例并且穿衣,把实例赋值给girl</span></span><br></pre></td></tr></table></figure></p>
<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><p>let: let在词典里解释是“允许，让；出租；假设；妨碍”，有种释放权力的意思。比如，let me past（让我过去）。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">richBoy?.let &#123;</span><br><span class="line">    it.buyPlane() <span class="comment">// 买飞机</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个富有的男孩如果真存在，他就可以去买飞机。买飞机毕竟是一种释放，花钱的洒脱，欲望的释放。</p>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a>with</h1><p>字典里意思是“在一起；具有”<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> girl = Girl()</span><br><span class="line">with(girl) &#123;</span><br><span class="line">    pet = Husky() <span class="comment">// 宠物二哈</span></span><br><span class="line">    mobile = Iphone(<span class="string">"xs plus"</span>) <span class="comment">// iPhone</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个女孩拥有二哈，iphone手机</p>
<h1 id="also"><a href="#also" class="headerlink" title="also"></a>also</h1><p>also是“也，而且”的意思<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> taxi = Taxi()</span><br><span class="line"><span class="keyword">val</span> richBoy = Girl().apply &#123;</span><br><span class="line">    getDressed() <span class="comment">// 穿衣服</span></span><br><span class="line">    makeUp() <span class="comment">// 化妆</span></span><br><span class="line">&#125;.also &#123;</span><br><span class="line">    taxi.drive(it) <span class="comment">// 计程车带她出门</span></span><br><span class="line">&#125;.run &#123;</span><br><span class="line">    attendDancingParty() <span class="comment">// 参加一个舞会</span></span><br><span class="line">    catchARichBoy() <span class="comment">// 钓到金龟婿</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个女孩应用一通（穿衣化妆），而且也让计程车带她出门，然后运行（参加舞会钓到金龟婿），把金龟婿赋值给richBoy</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/15/关于kotlin的几个扩展函数-run-apply-let-with-also/" data-id="ck5fynb53002ches6h3ajxuj6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kotlin/">kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin中链式调用的简单思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/25/kotlin中链式调用的简单思考/" class="article-date">
  <time datetime="2019-10-25T02:41:00.000Z" itemprop="datePublished">2019-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/25/kotlin中链式调用的简单思考/">kotlin中链式调用的简单思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有一个需求，获取app内容的高度，一般我会这样组织代码结构</p>
<ol>
<li>获取手机屏幕高度</li>
<li>如果当前手机状态栏在显示，就减去状态栏高度</li>
<li>如果当前手机虚拟导航栏在显示，就减去导航栏高度</li>
<li>返回处理后的高度</li>
</ol>
<p>我们先假定一些初始值（状态栏是否显示、状态栏高度、导航栏是否显示，导航栏高度等），代码大概是这样:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> statusBarHeight = <span class="number">32</span> <span class="comment">// we assume the value of statusbar's height is 32</span></span><br><span class="line"><span class="keyword">val</span> navigationBarHeight = <span class="number">128</span> <span class="comment">// we assume the value of nav's height is 128</span></span><br><span class="line"><span class="keyword">val</span> screenHeight = <span class="number">1920</span></span><br><span class="line"><span class="keyword">val</span> statusBarVisible = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> navigationBarVisible = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>以及<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodWithImperativeStyle</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> contentHeight = screenHeight</span><br><span class="line">    <span class="keyword">if</span> (statusBarVisible) &#123;</span><br><span class="line">        contentHeight -= statusBarHeight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (navigationBarVisible) &#123;</span><br><span class="line">        contentHeight -= navigationBarHeight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"contentHeight: <span class="variable">$contentHeight</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种写法倾向于面向过程的编程思维，于是，我写了一个支持链式调用的方法，并且把新的获取app内容的高度的实现方式显示如下。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">checkAndModify</span><span class="params">(condition: <span class="type">Boolean</span>, modify: (<span class="type">T</span>)</span></span> -&gt; T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        modify(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodWithChainedStyle</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> contentHeight = screenHeight.checkAndModify(statusBarVisible) &#123;</span><br><span class="line">        it - statusBarHeight</span><br><span class="line">    &#125;.checkAndModify(navigationBarVisible) &#123;</span><br><span class="line">        it - navigationBarHeight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"contentHeight: <span class="variable">$contentHeight</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家觉得怎么样？喜欢哪种方法呢？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/25/kotlin中链式调用的简单思考/" data-id="ck5fynb54002fhes6srdpwj58" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kotlin/">kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android输入法机制的学习总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/23/android输入法机制的学习总结/" class="article-date">
  <time datetime="2019-05-23T10:44:50.000Z" itemprop="datePublished">2019-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/23/android输入法机制的学习总结/">android输入法机制的学习总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>android输入法机制包含三部分：  </p>
<ol>
<li>输入法服务(InputMethodService)，简称IMS；  </li>
<li>输入法系统服务（InputMethodManagerService），简称IMMS；  </li>
<li>客户端app（即当前要输入内容的app）；</li>
</ol>
<p>android中的四大组件，其中经常用的包含Activity和Service。它们就像是系统和app通信的接口一样。通过Activity中可以展示UI，业务处理等。Service也同样可以做到。输入法就是靠Service来展示UI，业务处理的。</p>
<h1 id="抛出几个问题"><a href="#抛出几个问题" class="headerlink" title="抛出几个问题"></a>抛出几个问题</h1><ol>
<li>输入法Service是如何启动的呢？</li>
<li>输入法Service是如何展示UI（键盘）的呢？</li>
<li>第三方app如何向输入法service发信息的呢？比如发起弹键盘的请求。</li>
<li>该Service如何向第三方app发信息的呢？比如把按键信息传给第三方app的EditText。</li>
</ol>
<h1 id="整体概括"><a href="#整体概括" class="headerlink" title="整体概括"></a>整体概括</h1><p>输入法服务的启动以及和第三方app的关系的搭建，离不开IMMS（InputMethodManagerService）和其它系统服务。而启动、关系搭建、通信过程，离不开binder。</p>
<p>先把图奉上</p>
<p><img src="/images/my/ime/ime01.png" alt=""></p>
<p>图里边用红色数字标注的地方是用binder进行通信的，而蓝色标注的A，B处也是用binder通信，蓝色部分标注的是和普通app的按键触屏通信机制一样，在这里先不分析了。</p>
<p>首先简洁的一笔带过IMMS的启动，它的启动是在SystemServer运行起来时，会调用代码startOtherServices，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Start services.</span><br><span class="line">try &#123;</span><br><span class="line">    traceBeginAndSlog(&quot;StartServices&quot;);</span><br><span class="line">    startBootstrapServices();</span><br><span class="line">    startCoreServices();</span><br><span class="line">    startOtherServices();</span><br><span class="line">    SystemServerInitThreadPool.shutdown();</span><br><span class="line">&#125; catch (Throwable ex) &#123;</span><br><span class="line">    throw ex;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在startOtherServices中，有这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Bring up services needed for UI.</span><br><span class="line">if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">    mSystemServiceManager.startService(InputMethodManagerService.Lifecycle.class);</span><br><span class="line">    // ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是启动了InputMethodManagerService。具体代码在SystemServer.java中。而SystemServer属于什么进程？被谁启动？在这里不分析。</p>
<h1 id="输入法Service的启动"><a href="#输入法Service的启动" class="headerlink" title="输入法Service的启动"></a>输入法Service的启动</h1><p>那么输入法服务是被谁启动的呢？没错，是它是它就是它，我们的朋友IMMS。摘一段IMMS的代码（来自于InputMethodManagerService.java），删去了一些代码，简化如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">InputBindResult startInputInnerLocked() &#123;</span><br><span class="line">    InputMethodInfo info = mMethodMap.get(mCurMethodId);</span><br><span class="line">    mCurIntent = new Intent(InputMethod.SERVICE_INTERFACE);</span><br><span class="line">    mCurIntent.setComponent(info.getComponent());</span><br><span class="line">    mCurIntent.putExtra(Intent.EXTRA_CLIENT_LABEL,</span><br><span class="line">            com.android.internal.R.string.input_method_binding_label);</span><br><span class="line">    mCurIntent.putExtra(Intent.EXTRA_CLIENT_INTENT, PendingIntent.getActivity(</span><br><span class="line">            mContext, 0, new Intent(Settings.ACTION_INPUT_METHOD_SETTINGS), 0));</span><br><span class="line">    if (bindCurrentInputMethodService(mCurIntent, this, IME_CONNECTION_BIND_FLAGS)) &#123;</span><br><span class="line">        mCurToken = new Binder();</span><br><span class="line">        mIWindowManager.addWindowToken(mCurToken, TYPE_INPUT_METHOD, DEFAULT_DISPLAY);</span><br><span class="line">        return new InputBindResult(null, null, mCurId, mCurSeq,</span><br><span class="line">                mCurUserActionNotificationSequenceNumber);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mCurIntent = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码我们看到了这个方法里，绑定了当前输入法服务（bindCurrentInputMethodService）。为什么当前输入法呢？看代码这里<code>InputMethodInfo info = mMethodMap.get(mCurMethodId)</code>。map这里存储了百度、搜狗、讯飞、KK等一系列输入法的信息。至于mIWindowManager.addWindowToken和InputBindResult，先不考虑。只需要简要知道，这个方法启动了输入法服务。</p>
<p>这个方法是被谁调用的呢？它是被IMMS中的startInputOrWindowGainedFocus方法调用，而startInputOrWindowGainedFocus是被第三方app请求弹起输入法时通过binder机制调用。（startInputOrWindowGainedFocus是在IInputMethodManager.aidl声明的）。</p>
<p>第三方app请求弹起输入法时是如何通过binder机制调用到这里startInputOrWindowGainedFocus的？这里要看第三方app进程中的InputMethodManager。</p>
<h2 id="InputMethodManager"><a href="#InputMethodManager" class="headerlink" title="InputMethodManager"></a>InputMethodManager</h2><p>InputMethodManager是第三方app所在进程的一个对象，它有startInputInner这个方法，方法内部有一段这样的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"> 		// ...</span><br><span class="line">		final InputBindResult res = mService.startInputOrWindowGainedFocus(</span><br><span class="line">                        startInputReason, mClient, windowGainingFocus, 							 controlFlags, softInputMode,</span><br><span class="line">                        windowFlags, tba, servedContext,missingMethodFlags);</span><br><span class="line">&#125; catch (RemoteException e) &#123;</span><br><span class="line">        // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，注意！第三方app这里也调用了startInputOrWindowGainedFocus方法，它和IMMS中的startInputOrWindowGainedFocus是通过binder机制通信的。</p>
<p>InputMethodManager的startInputInner方法会在编辑框获取焦点时被调用。</p>
<h1 id="输入法服务如何展现UI键盘"><a href="#输入法服务如何展现UI键盘" class="headerlink" title="输入法服务如何展现UI键盘"></a>输入法服务如何展现UI键盘</h1><p>先上个图，展示输入法服务的类继承关系。</p>
<p><img src="/images/my/ime/ime02.png" alt=""></p>
<p>在去了解AbstractInputMethodService、InputMethodService前，先抛出一个认知。</p>
<p>通常我们要展示一个界面时，除了用activity之外，我们也可以获取WindowManager，然后调用它的addView。也可以通过popupwindow、dialog展示界面。</p>
<p>输入法的界面就是靠最后一种方式（dialog）展示出来的，而调用dialog的地方，必然是在AbstractInputMethodService、InputMethodService这2个类中某一个地方。</p>
<p>然后，我们去分析一下InputMethodService。发现该类中有个私有字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftInputWindow mWindow;</span><br></pre></td></tr></table></figure>
<p>而这个SoftInputWindow正是继承了Dialog。那么说，输入法的UI所需要的view，必然是添加到mWindow中，然后靠mWindow的show方法来显示界面。照这个思路去分析相应的代码。</p>
<p>在InputMethodService重写的onCreate方法中，创建了SoftInputWindow实例，该实例赋值给mWindow，然后调用方法initViews()。在initViews方法中，创建了一个<code>mRootView</code>，然后把该<code>mRootView</code>作为参数传入到mWindow的setContentView方法中。</p>
<p>InputMethodService提供了一个方法<code>public View onCreateInputView()</code>，该方法返回的view是挂接到<code>mRootView</code>的树结构的某一个节点上的，然后我们就可以继承InputMethodService来实现这个<code>onCreateInputView()</code>，这样就可以自定义键盘的外观了。</p>
<p>回头总结下，原来输入法service中有个mWindow，类型是继承了Dialog的SoftInputWindow，它的contentView是mRootView，然后输入法的view是通过onCreateInputView()方法创建出来后，挂接到mRootView中的。</p>
<p>而什么时候调用mWindow的show方法呢？我们看到InputMethodService有个方法showWindowInner，在这个方法尾部调用了<code>mWindow.show()</code>。那么showWindowInner是干什么的?谁调用了它?看名字就知道它是要弹起输入法，一定是弹起输入法时，某个系统回调中调用了它。</p>
<p>我把showWindowInner方法的代码展示出来入下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">void showWindowInner(boolean showInput) &#123;</span><br><span class="line">    boolean doShowInput = false;</span><br><span class="line">    final int previousImeWindowStatus =</span><br><span class="line">            (mWindowVisible ? IME_ACTIVE : 0) | (isInputViewShown() ? IME_VISIBLE : 0);</span><br><span class="line">    mWindowVisible = true;</span><br><span class="line">    if (!mShowInputRequested &amp;&amp; mInputStarted &amp;&amp; showInput) &#123;</span><br><span class="line">        doShowInput = true;</span><br><span class="line">        mShowInputRequested = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG) Log.v(TAG, &quot;showWindow: updating UI&quot;);</span><br><span class="line">    initialize();</span><br><span class="line">    updateFullscreenMode();</span><br><span class="line">    updateInputViewShown();</span><br><span class="line">    </span><br><span class="line">    if (!mWindowAdded || !mWindowCreated) &#123;</span><br><span class="line">        mWindowAdded = true;</span><br><span class="line">        mWindowCreated = true;</span><br><span class="line">        initialize();</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;CALL: onCreateCandidatesView&quot;);</span><br><span class="line">        View v = onCreateCandidatesView();</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;showWindow: candidates=&quot; + v);</span><br><span class="line">        if (v != null) &#123;</span><br><span class="line">            setCandidatesView(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mShowInputRequested) &#123;</span><br><span class="line">        if (!mInputViewStarted) &#123;</span><br><span class="line">            if (DEBUG) Log.v(TAG, &quot;CALL: onStartInputView&quot;);</span><br><span class="line">            mInputViewStarted = true;</span><br><span class="line">            onStartInputView(mInputEditorInfo, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (!mCandidatesViewStarted) &#123;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;CALL: onStartCandidatesView&quot;);</span><br><span class="line">        mCandidatesViewStarted = true;</span><br><span class="line">        onStartCandidatesView(mInputEditorInfo, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (doShowInput) &#123;</span><br><span class="line">        startExtractingText(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int nextImeWindowStatus = IME_ACTIVE | (isInputViewShown() ? IME_VISIBLE : 0);</span><br><span class="line">    if (previousImeWindowStatus != nextImeWindowStatus) &#123;</span><br><span class="line">        mImm.setImeWindowStatus(mToken, mStartInputToken, nextImeWindowStatus,</span><br><span class="line">                mBackDisposition);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((previousImeWindowStatus &amp; IME_ACTIVE) == 0) &#123;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;showWindow: showing!&quot;);</span><br><span class="line">        onWindowShown();</span><br><span class="line">        mWindow.show();</span><br><span class="line">        // Put here rather than in onWindowShown() in case people forget to call</span><br><span class="line">        // super.onWindowShown().</span><br><span class="line">        mShouldClearInsetOfPreviousIme = false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里说的净是InputMethodService内部的东西，AbstractInputMethodService到底干了什么？以后会分析。</p>
<h1 id="第三方app和输入法service如何通信"><a href="#第三方app和输入法service如何通信" class="headerlink" title="第三方app和输入法service如何通信"></a>第三方app和输入法service如何通信</h1><p>第三方app可以控制输入法弹出和收起等。我们都知道进程间通信靠binder。这里也不例外。but！！！还记得这个输入法Service是在IMMS中bind的吧(不记得了就查IMMS中的这个方法bindCurrentInputMethodService)，而不是在第三方app中bind的。所以这个输入法service所对应的binder对象应该是存在于IMMS，而现在是要第三方app通过持有的binder向输入法service通信，该怎么办？</p>
<p>最初始的binder关联是这样的。</p>
<p><img src="/images/my/ime/ime03.png" alt=""></p>
<p>紧接着第三方app通过IMMS和IMS进行通信，于是就变成了这样。</p>
<p><img src="/images/my/ime/ime04.png" alt=""></p>
<p>这样就可以实现，客户端app去通知输入法Service弹出键盘，在通知时，把自己的一个binder作为参数最终传给了IMS，于是就变成了这样。IMS可以通过这个binder向客户端app通信。</p>
<p><img src="/images/my/ime/ime05.png" alt=""></p>
<p>此时大家会发出质疑，“是这样吗？没代码你说个河蟹啊。上代码！”</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="第三方app持有IMMS的binder"><a href="#第三方app持有IMMS的binder" class="headerlink" title="第三方app持有IMMS的binder"></a>第三方app持有IMMS的binder</h3><p>第三方app是如何持有IMMS的binder的呢？第三方app运行起来后，会持有一个InputMethodManager对象（简称IMM），平时调用<code>context.getSystemService(Context.INPUT_METHOD_SERVICE)</code>就是获取的这个IMM，IMM的构造方式是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputMethodManager(Looper looper) throws ServiceNotFoundException &#123;</span><br><span class="line">    this(IInputMethodManager.Stub.asInterface(</span><br><span class="line">            ServiceManager.getServiceOrThrow(Context.INPUT_METHOD_SERVICE)), looper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个IInputMethodManager对应的就是InputMethodManagerService，我们看IMMS的类的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class InputMethodManagerService extends IInputMethodManager.Stub</span><br><span class="line">        implements ServiceConnection, Handler.Callback &#123;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>IInputMethodManager对应的aidl文件是IInputMethodManager.aidl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface IInputMethodManager &#123;</span><br><span class="line">    void addClient(in IInputMethodClient client,</span><br><span class="line">            in IInputContext inputContext, int uid, int pid);</span><br><span class="line">    boolean showSoftInput(in IInputMethodClient client, int flags,</span><br><span class="line">            in ResultReceiver resultReceiver);</span><br><span class="line">    boolean hideSoftInput(in IInputMethodClient client, int flags,</span><br><span class="line">            in ResultReceiver resultReceiver);</span><br><span class="line">    InputBindResult startInputOrWindowGainedFocus(int startInputReason,</span><br><span class="line">            in IInputMethodClient client, in IBinder windowToken, int controlFlags,int softInputMode,int windowFlags, in EditorInfo attribute, IInputContext inputContext,int missingMethodFlags,int unverifiedTargetSdkVersion);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IMMS持有输入法Service的binder"><a href="#IMMS持有输入法Service的binder" class="headerlink" title="IMMS持有输入法Service的binder"></a>IMMS持有输入法Service的binder</h3><p>IMMS在调用bindCurrentInputMethodService时，传入了一个ServiceConnection（其实就是IMMS自己实现了这个接口）。</p>
<p><img src="/images/my/ime/ime06.png" alt=""></p>
<p>在onServiceConnected方法中获取到类型是IInputMethod的binder，并赋值给mCurMethod。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">    synchronized (mMethodMap) &#123;</span><br><span class="line">        if (mCurIntent != null &amp;&amp; name.equals(mCurIntent.getComponent())) &#123;</span><br><span class="line">            mCurMethod = IInputMethod.Stub.asInterface(service);</span><br><span class="line">            if (mCurToken == null) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Service connected without a token!&quot;);</span><br><span class="line">                unbindCurrentMethodLocked(false);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            executeOrSendMessage(mCurMethod, mCaller.obtainMessageOO(</span><br><span class="line">                    MSG_ATTACH_TOKEN, mCurMethod, mCurToken));</span><br><span class="line">            if (mCurClient != null) &#123;</span><br><span class="line">                clearClientSessionLocked(mCurClient);</span><br><span class="line">                requestClientSessionLocked(mCurClient);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在输入法Service这一端，上边提到到AbstractInputMethodService开始发挥自己的功能了，它实现了onBind方法，返回IInputMethodWrapper。IInputMethodWrapper继承了一个Stub，实现了IInputMethod接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">final public IBinder onBind(Intent intent) &#123;</span><br><span class="line">    if (mInputMethod == null) &#123;</span><br><span class="line">        mInputMethod = onCreateInputMethodInterface();</span><br><span class="line">    &#125;</span><br><span class="line">    return new IInputMethodWrapper(this, mInputMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IInputMethod.aidl如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">oneway interface IInputMethod &#123;</span><br><span class="line">    void attachToken(IBinder token);</span><br><span class="line">    void bindInput(in InputBinding binding);</span><br><span class="line">    void unbindInput();</span><br><span class="line">    void startInput(in IBinder startInputToken, in IInputContext inputContext, int missingMethods,</span><br><span class="line">            in EditorInfo attribute, boolean restarting);</span><br><span class="line">    void createSession(in InputChannel channel, IInputSessionCallback callback);</span><br><span class="line">    void setSessionEnabled(IInputMethodSession session, boolean enabled);</span><br><span class="line">    void revokeSession(IInputMethodSession session);</span><br><span class="line">    void showSoftInput(int flags, in ResultReceiver resultReceiver);</span><br><span class="line">    void hideSoftInput(int flags, in ResultReceiver resultReceiver);</span><br><span class="line">    void changeInputMethodSubtype(in InputMethodSubtype subtype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在知道了:</p>
<ol>
<li>第三方app持有IMMS的binder IInputMethodManager，这个IInputMethodManager实现类就是IMMS(InputMethodManagerService);</li>
<li>IMMS持有输入法Service的binder IInputMethod，这个IInputMethod的实现类是IInputMethodWrapper；</li>
</ol>
<h3 id="app和输入法关联"><a href="#app和输入法关联" class="headerlink" title="app和输入法关联"></a>app和输入法关联</h3><p>app向IMMS发起可输入请求，是靠调用IInputMethodManager的startInputOrWindowGainedFocus，IMMS收到消息后，向输入法service发起请求，是靠调用IInputMethod的startInput。</p>
<p>注意！注意！这两个aidl的startInput都有个参数IInputContext，它也是个binder。这个参数最终传给了输入法Service。具体代码如下。</p>
<p>第三方app端，InputMethodManager的方法startInputInner中有一段代码是</p>
<p><img src="/images/my/ime/ime07.png" alt=""><br>这个ControlledInputConnectionWrapper既是IInputContext的binder。</p>
<p>IMMS收到消息后如何发送消息startInput给IMS的，IMMS这里边逻辑太多，这里不再细说。</p>
<p>IMS端IInputMethodWrapper.java中，类型是IInputContext的inputContext作为参数传给了InputConnectionWrapper，InputConnectionWrapper对象赋值给了InputConnection。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case DO_START_INPUT: &#123;</span><br><span class="line">    final SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">    final int missingMethods = msg.arg1;</span><br><span class="line">    final boolean restarting = msg.arg2 != 0;</span><br><span class="line">    final IBinder startInputToken = (IBinder) args.arg1;</span><br><span class="line">    final IInputContext inputContext = (IInputContext) args.arg2;</span><br><span class="line">    final EditorInfo info = (EditorInfo) args.arg3;</span><br><span class="line">    final InputConnection ic = inputContext != null</span><br><span class="line">            ? new InputConnectionWrapper(mTarget, inputContext, missingMethods) : null;</span><br><span class="line">    info.makeCompatible(mTargetSdkVersion);</span><br><span class="line">    inputMethod.dispatchStartInputWithToken(ic, info, restarting /* restarting */,</span><br><span class="line">            startInputToken);</span><br><span class="line">    args.recycle();</span><br><span class="line">    return;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>总结一下。</p>
<ol>
<li>客户端app通过IMMS，把IInputContext这个binder传递给了IMS，这个过程都使用了binder机制。</li>
<li>IMS端靠这个IInputContext向客户端app发送指令（文字、符号等）。</li>
</ol>
<p>IInputContext.aidl是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">oneway interface IInputContext &#123;</span><br><span class="line">    void deleteSurroundingText(int leftLength, int rightLength);</span><br><span class="line">    void commitText(CharSequence text, int newCursorPosition);</span><br><span class="line">    void commitCompletion(in CompletionInfo completion);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br></p>
<h1 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h1><h1 id="IMS一端"><a href="#IMS一端" class="headerlink" title="IMS一端"></a>IMS一端</h1><h2 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h2><p>我先把类列出来</p>
<ol>
<li>InputMethodService；</li>
<li>IInputMethodWrapper;</li>
<li>InputMethod &lt;|– AbstractInputMethodImpl &lt;|– InputMethodImpl;</li>
<li>InputConnectionWrapper(它实现了InputConnection接口);</li>
<li>InputContextCallback;</li>
</ol>
<p>这些类的关系是什么呢，于是根据代码画了一张UML图</p>
<p><img src="/images/my/ime/ime08.png" alt=""></p>
<p>概括说，service通过onBind()返回一个继承了Stub的IInputMethodWrapper对象，IInputMethodWrapper内部弱引用了一个InputMethodImpl对象。那么InputConnectionWrapper对象是如何被最终传递给service的呢。于是我画了一个时序图，如下。</p>
<p><img src="/images/my/ime/ime09.png" alt=""></p>
<p>远程IPC调用IInputMethodWrapper的startInput方法，把IInputContext引用的对象传递过来，通过时序图可以看到InputMethodService是如何得到InputConnectionWrapper对象的，从而间接地可以得到IInputContext引用的对象（InputConnectionWrapper内聚了IInputContext）。这就赋予了servie远程和第三方app客户端通信的能力。这个IInputContext提供了什么接口，service就可以和客户端做什么通信。比如它有个<code>void commitText(CharSequence text, int newCursorPosition);</code>接口，可以使得service提交文字到客户端相应的EditText中。</p>
<p><strong>注意</strong>，这里的IInputMethodWrapper是继承了IInputMethod.Stub,所以它 is-a Binder，实现了aidl定义的接口<strong>IInputMethod</strong>，而不是<strong>InputMethod</strong>。 这个容易迷惑人，<strong>InputMethod</strong>不是aidl定义的。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol>
<li>IInputConnectionWrapper;</li>
<li>ControlledInputConnectionWrapper；</li>
</ol>
<p>IInputConnectionWrapper相关的类的关系如下</p>
<p><img src="/images/my/ime/ime10.png" alt=""></p>
<p>在客户端的InputMethodManager的startInputInner方法中，创建了ControlledInputConnectionWrapper对象，并把它作为参数调用IInputMethodManager的startInputOrWindowGainedFocus。IInputMethodManager正是IMMS对应的binder，这样就通过IMMS把ControlledInputConnectionWrapper对应的binder传递给了IMS端。</p>
<p>不难想象，这里的ControlledInputConnectionWrapper所对应的service端的正是InputConnectionWrapper里边的IInputContext。</p>
<p><img src="/images/my/ime/ime11.png" alt=""></p>
<h2 id="系统服务端"><a href="#系统服务端" class="headerlink" title="系统服务端"></a>系统服务端</h2><p>InputMethodManagerService</p>
<p>IMS端和客户端共用：InputConnection</p>
<h2 id="需要用到的aidl"><a href="#需要用到的aidl" class="headerlink" title="需要用到的aidl"></a>需要用到的aidl</h2><ol>
<li>IInputContextCallback.aidl</li>
<li>IInputContext.aidl</li>
<li>InputBinding.aidl</li>
<li>IInputMethod.aidl</li>
<li>IInputMethodManager.aidl</li>
<li>IInputMethodClient.aidl</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/23/android输入法机制的学习总结/" data-id="ck5fynb95003shes60qgp1zzg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-对java的class文件的字节码的分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/16/对java的class文件的字节码的分析/" class="article-date">
  <time datetime="2019-05-16T07:10:31.000Z" itemprop="datePublished">2019-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/16/对java的class文件的字节码的分析/">对java的class文件的字节码的分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近有时会聊到java类的字节码，做了这么多年android开发，还真不了解它，于是想探索一下。</p>
<p>先写了一个简单的java类MyClass，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后分析它的class文件。找到生成的MyClass.class之后，用<code>vim -b MyClass.class</code>打开。打开后，是这样的，一脸懵逼。</p>
<p><img src="/images/my/java/00.png" alt=""></p>
<p>不要紧，在vim中输入命令<code>:%! xxd</code>，展现这样的内容：</p>
<p><img src="/images/my/java/01.png" alt=""></p>
<p>把字节码取出来，逐个分析。</p>
<h3 id="cafe-babe"><a href="#cafe-babe" class="headerlink" title="cafe babe"></a>cafe babe</h3><p>每个Class文件的头四个字节称为魔数，它的唯一作用是用来确定该文件是否为一个能被虚拟机接受的Class文件</p>
<h3 id="0000-0035"><a href="#0000-0035" class="headerlink" title="0000 0035"></a>0000 0035</h3><p>对应java class的版本号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2 minor_version;//次版本号</span><br><span class="line">u2 major_version;//主版本号</span><br></pre></td></tr></table></figure></p>
<p>次版本号在前，主版本号在后。minor_version是0，major_version是16进制的35。</p>
<h3 id="0015"><a href="#0015" class="headerlink" title="0015"></a>0015</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2  constant_pool_count;//常量池容量计数</span><br></pre></td></tr></table></figure>
<p>换算成10进制，常量的个数是21，这就代表常量池中有20项常量，索引值范围为1～20。（计数从1开始，其他计数从0开始，因为0有其他作用）</p>
<p>选中部分既是常量池。<br><img src="/images/my/java/02.png" alt=""></p>
<p>分析常量池得出以下几项<br><img src="/images/my/java/03.png" alt=""></p>
<p>如果用<code>javap -p -v MyClass.class</code>看，则是</p>
<p><img src="/images/my/java/04.png" alt=""></p>
<p>接下来分析一下每一项的含义</p>
<h3 id="0a-00-04-00-11"><a href="#0a-00-04-00-11" class="headerlink" title="0a 00 04 00 11"></a>0a 00 04 00 11</h3><p>该常量类型是<code>CONSTANT_Methodref_info</code><br>它的结构体是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 class_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>items</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>tag</td>
<td>CONSTANT_Methodref_info结构的tag值为10</td>
</tr>
<tr>
<td>class_index</td>
<td>CONSTANT_Methodref_info结构的class_index必须是一个类类型，而不是接口类型</td>
</tr>
<tr>
<td>name_and_type_index</td>
<td>name_and_type_index的值必须是constant_pool表中的一个有效索引；这索引值上的对应的常量池条目（The constant_pool entry）也一定是CONSTANT_NameAndType_info结构；这个条目也是具有字段或方法作为成员的类或接口类型</td>
</tr>
</tbody>
</table>
<p>它的class_index为4，对应的是第四项，它的name_and_type_index是17。我们先分析下第四项是什么。</p>
<h4 id="07-00-14"><a href="#07-00-14" class="headerlink" title="07 00 14"></a>07 00 14</h4><p>这是第4项，07代表CONSTANT_class，它的结构是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>index为14，代表的是索引值是20的那一项，我们再顺着分析下第20项。</p>
<p>第20项是CONSTANT_Utf8_info，tag是1，它的结构是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第20项的值是<code>01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74</code>,其中tag是1，length是16，bytes是<code>java/lang/Object</code>(表示的字符串是 java/lang/Object)</p>
<p>回过头来我们分析下第17项的name_and_type_index</p>
<h4 id="0c-00-07-00-08"><a href="#0c-00-07-00-08" class="headerlink" title="0c 00 07 00 08"></a>0c 00 07 00 08</h4><p>这是第17项，它的结构是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Name_AndType_info &#123;</span><br><span class="line">    u1 tag;     // 值是12</span><br><span class="line">    u2 index;   // 指向该字段或方法名称常量项的索引</span><br><span class="line">    u2 index;   // 指向该字段或方法描述符常量项的索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，两个index分别是7和8，于是我们又转向第7项和第8项，第7项和第8项可以看出来，他们的值分别是<code>01 00 06 3c 69 6e 69 74 3e</code>和<code>01 00 03 28 29 56</code>。它们又都是CONSTANT_Utf8_info结构，字符串分别是<code>&lt;init&gt;</code>和<code>()V</code>。</p>
<p>方法名称<code>&lt;init&gt;</code>和方法描述符<code>()V</code>指的是什么呢？指的是一个实例初始方法，没有参数，返回类型也一定是 void。</p>
<p>回过头来我理一下它们的关联，用图来表示如下。</p>
<p><img src="/images/my/java/05.png" alt=""><br>所以#1 Methodref表示的含义是<code>java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></p>
<h3 id="09-00-03-00-12"><a href="#09-00-03-00-12" class="headerlink" title="09 00 03 00 12"></a>09 00 03 00 12</h3><p>同样道理，分析第2项是。用图来表示如下。</p>
<p><img src="/images/my/java/06.png" alt=""><br>所以#2 Fieldref表示的含义是<code>MyClass.i:I</code>，MyClass类的字段i，类型是整型。</p>
<p>至于别的常量，后边再分析。</p>
<h3 id="常量池后边的00-21"><a href="#常量池后边的00-21" class="headerlink" title="常量池后边的00 21"></a>常量池后边的00 21</h3><p>MyClass是一个普通Java类，不是接口、枚举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、CC_ENUM这6个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。</p>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><p><code>00 21</code>之后就是<code>00 03 00 04</code>，<code>00 03</code>代表上边常量池中的第3项MyClass，这是类索引，<code>00 04</code>代表上边常量池中第4项java/lang/Object，这是父类索引。</p>
<p>紧接着是<code>00 00</code>表示接口索引的个数。因为MyClass没有实现接口，所以个数是0。</p>
<h3 id="field"><a href="#field" class="headerlink" title="field"></a>field</h3><h4 id="field-count"><a href="#field-count" class="headerlink" title="field count"></a>field count</h4><p>紧接着是字段个数 <code>00 01</code>，表示有一个字段。那当然是i了，接下来看字段i在字节码中是如何表示的。</p>
<p><img src="/images/my/java/07.png" alt=""></p>
<h4 id="field-结构"><a href="#field-结构" class="headerlink" title="field 结构"></a>field 结构</h4><p>这8个字节表示的结构是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2             access_flags;            // 2</span><br><span class="line">    u2             name_index;              // 5</span><br><span class="line">    u2             descriptor_index;        // 6</span><br><span class="line">    u2             attributes_count;        // 0</span><br><span class="line">    attribute_info attributes[attributes_count];        // null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>access_flags是2,表示ACC_PRIVATE，私有成员。name_index是5，是常量池中的第5项i，descriptor_index是6，是常量池中的第6项，I，代表整型。</p>
<p><strong>留下来个问题，attributes_count为什么是0，attribute_info在这里是什么含义？</strong></p>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>接下来的字节码存储的是java的方法</p>
<h4 id="methods-count"><a href="#methods-count" class="headerlink" title="methods count"></a>methods count</h4><p><code>00 02</code>表示两个方法。为什么是两个方法，当然是<init>和inc了。且看是如何存储在字节码中的。</init></p>
<h4 id="第一个方法"><a href="#第一个方法" class="headerlink" title="第一个方法"></a>第一个方法</h4><p>第一个方法在字节码中的存储是</p>
<p><img src="/images/my/java/08.png" alt=""></p>
<p>首先映入眼帘的是<code>00 01 00 07 00 08 00 01</code>，<code>00 01</code>表示ACC_PUBLIC，说明是public方法，<code>00 07</code>是常量池第7项索引，表示方法名<code>&lt;init&gt;</code>，<code>00 08</code>是常量池第8项索引，表示方法描述符<code>()V</code>。<code>00 01</code>表示attributes_count, 对应的结构是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2             access_flags;        // 1</span><br><span class="line">    u2             name_index;          // 7</span><br><span class="line">    u2             descriptor_index;    // 8</span><br><span class="line">    u2             attributes_count;    // 1</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么剩下的就是属性信息了，对应的结构是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index;        // 9</span><br><span class="line">    u4 attribute_length;            // 00 00 00 2f，即47</span><br><span class="line">    u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>00 09</code>表示常量池中属性名称索引是第9项，常量池中第9项是Code，说明属性名称是Code。</p>
<p><code>u1 info[attribute_length]</code>对应的字节码信息是：</p>
<p><img src="/images/my/java/09.png" alt=""></p>
<p>这些字节码存储的信息是：</p>
<p><img src="/images/my/java/10.png" alt=""></p>
<p>其中字节码指令就是<code>2a b7 00 01 b1</code>，分析这些指令。</p>
<ol>
<li>读入2a，查表得0x2A对应的指令为aload_0，这个指令的含义是将第0个Slot中为reference类型的本地变量推送到操作数栈顶。</li>
<li>读入b7，查表得0xB7对应的指令为invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的方法符号引用。</li>
<li>读入00 01，这是invokespecial的参数，查常量池得0x0001对应的常量为实例构造器＜init＞方法的符号引用。</li>
<li>读入b1，查表得0xB1对应的指令为return，含义是返回此方法，并且返回值为void。这条指令执行后，当前方法结束。</li>
</ol>
<p><code>通过javap -p -v MyClass.class可以看到</code></p>
<p><img src="/images/my/java/11.png" alt=""></p>
<p>剩下的字节码是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000a</span><br><span class="line">0000 0006 0001 0000 0001 000b 0000 000c</span><br><span class="line">0001 0000 0005 000c 000d 0000</span><br></pre></td></tr></table></figure></p>
<p>剩下的字节码表示attributes，这些attributes是什么呢？attributes一共有2个属性，LineNumberTable和LocalVariableTable。</p>
<p>其中<code>000a 0000 0006 0001 0000 0001</code>代表LineNumberTable_attribute这个结构，这个结构是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;        // 00 0a，常量池中的第10项</span><br><span class="line">    u4 attribute_length;            // 0000 0006,属性长度是6个字节长</span><br><span class="line">    u2 line_number_table_length;    // 0001,只有1个line_number_table</span><br><span class="line">    &#123;   u2 start_pc;                // 0000，字节码行号</span><br><span class="line">        u2 line_number;             // 0001，Java源码行号</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LineNumberTable的作用在于，如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</p>
<p>其中<code>000b 0000 000c 0001 0000 0005 000c 000d 0000</code>表示LocalVariableTable_attribute,这个结构是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;                // 000b常量池中第11项</span><br><span class="line">    u4 attribute_length;        // 000 000c，属性长度是12个字节</span><br><span class="line">    u2 local_variable_table_length; // 0001，只有1个local_variable_table</span><br><span class="line">    &#123;   u2 start_pc;        // 0000</span><br><span class="line">        u2 length;          // 0005</span><br><span class="line">        u2 name_index;      // 000c，常量池中的第12项，this</span><br><span class="line">        u2 descriptor_index;    // 000d</span><br><span class="line">        u2 index;       // 0000</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。可以看到里边有个local_variable_table。它的含义如下。</p>
<p><strong>start_pc和length</strong> 代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</p>
<p><strong>name_index和descriptor_index</strong><br>指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符</p>
<p><strong>index</strong><br>这个局部变量在栈帧局部变量表中Slot的位置。当这个变量数据类型是64位类型时（double和long），它占用的Slot为index和index+1两个</p>
<h4 id="第二个方法"><a href="#第二个方法" class="headerlink" title="第二个方法"></a>第二个方法</h4><p>我们再来分析第2个方法，它的字节码一共是</p>
<p><img src="/images/my/java/12.png" alt=""></p>
<p>简单分析入下：<br><code>0001 000e 0008 0001</code>表示的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2             access_flags; // 0001， ACC_PUBLIC, 表示public方法</span><br><span class="line">    u2             name_index;  // 000e, 常量池索引，表示第14项，inc</span><br><span class="line">    u2             descriptor_index; // 0008，常量池索引，表示第8项，()V</span><br><span class="line">    u2             attributes_count; // 0001，1个attribute_info</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>0009 0000 0039</code> 表示的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index; // 0009,常量索引，表示Code</span><br><span class="line">    u4 attribute_length;    // 0000 0039, 十进制是57，表示info的长度</span><br><span class="line">    u1 info[attribute_length]; // 长度为57，该表示该java方法的字节块的剩余部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来分析info[57]，是</p>
<p><img src="/images/my/java/13.png" alt=""></p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>名字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0003</td>
<td>max_stack</td>
<td>操作数栈（Operand Stacks）深度的最大值</td>
</tr>
<tr>
<td>0001</td>
<td>max_locals</td>
<td>max_locals代表了局部变量表所需的存储空间</td>
</tr>
<tr>
<td>0000 000b</td>
<td>code_length</td>
<td>代表字节指令码的长度</td>
</tr>
<tr>
<td>2a59 b400 0204 60b5 0002 b1</td>
<td>code</td>
<td>code指令码</td>
</tr>
<tr>
<td>00 00</td>
<td>exception_table_length</td>
<td>异常表长度</td>
</tr>
<tr>
<td>无</td>
<td>exception_table</td>
<td></td>
</tr>
<tr>
<td>00 02</td>
<td>attributes_count</td>
<td>属性数量</td>
</tr>
<tr>
<td>00 0a00 0000 0a00 0200 0000 0500 0a00 06</td>
<td>LineNumberTable</td>
<td></td>
</tr>
<tr>
<td>00 0b00 0000 0c00 0100 0000 0b00 0c00 0d00 00</td>
<td>LocalVariableTable</td>
</tr>
</tbody>
</table>
<p>其中<code>00 0a00 0000 0a00 0200 0000 0500 0a00 06</code>对应的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index; // 00 0a</span><br><span class="line">    u4 attribute_length;    //  00 00 00 0a</span><br><span class="line">    u2 line_number_table_length; // 00 02</span><br><span class="line">    </span><br><span class="line">    // 这里line_number_table数组长是2,分别是[ &#123;00 00, 00 05&#125;,&#123;00 0a, 00 06&#125;]</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 line_number; </span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上边内容已经分析过它的含义，这里不再分析。</p>
<p>其中<code>00 0b00 0000 0c00 0100 0000 0b00 0c00 0d00 00</code>对应的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;    // 00 0b，常量池索引</span><br><span class="line">    u4 attribute_length; // 00 00 00 0c</span><br><span class="line">    </span><br><span class="line">    // 这里应该也是在描述this这个变量</span><br><span class="line">    u2 local_variable_table_length; // 00 01</span><br><span class="line">    &#123;   u2 start_pc; // 00 00</span><br><span class="line">        u2 length; // 00 0b 字节码中的作用域范围</span><br><span class="line">        u2 name_index; // 00 0c</span><br><span class="line">        u2 descriptor_index; // 00 0d</span><br><span class="line">        u2 index; // 00 00</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，注意，其中关键的code码指令<code>2a59 b400 0204 60b5 0002 b1</code>，我们没有分析。</p>
<table>
<thead>
<tr>
<th>code码</th>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>2a</td>
<td>aload_0</td>
<td>第0个Slot中为reference类型的本地变量（通常是this）推送到操作数栈顶</td>
</tr>
<tr>
<td>59</td>
<td>dup</td>
<td>复制栈顶。相当于把操作数栈顶元素pop出来，再把它push进去2次</td>
</tr>
<tr>
<td>b4 00 02</td>
<td>getfield</td>
<td>获取对象的字段，将其值压入栈顶</td>
</tr>
<tr>
<td>04</td>
<td>iconst_1</td>
<td>int型常量1进栈</td>
</tr>
<tr>
<td>60</td>
<td>iadd</td>
<td>加法</td>
</tr>
<tr>
<td>b5 00 02</td>
<td>putfield</td>
<td>给对象的字段赋值</td>
</tr>
<tr>
<td>b1</td>
<td>return</td>
<td>返回此方法，并且返回值为void</td>
</tr>
</tbody>
</table>
<h3 id="最后边的字节码"><a href="#最后边的字节码" class="headerlink" title="最后边的字节码"></a>最后边的字节码</h3><p><code>00 0100 0f00 0000 0200 10</code>表示什么含义呢？</p>
<p><img src="/images/my/java/14.png" alt=""></p>
<p><strong>00 01</strong> 表示attribute count为1</p>
<p><strong>00 0f00 0000 0200 10</strong> 表示attribute_info</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index;    // 00 0f，常量池中的SourceFile</span><br><span class="line">    u4 attribute_length;        // 00 00 00 02，属性长度是2</span><br><span class="line">    u1 info[attribute_length]; // 00 10，常量池第16项的MyClass.java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是ClassFile最后的1个属性。</p>
<p>至此，大概分析了一下。<br>感谢<a href="https://blog.csdn.net/qq_31156277/article/details/80108277" target="_blank" rel="noopener">https://blog.csdn.net/qq_31156277/article/details/80108277</a>，整个分析过程是靠这篇博客的讲解来的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/16/对java的class文件的字节码的分析/" data-id="ck5fynb71003lhes67r1plcbw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-编程语言的容器的学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/07/编程语言的容器的学习/" class="article-date">
  <time datetime="2019-04-07T07:53:13.000Z" itemprop="datePublished">2019-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/07/编程语言的容器的学习/">编程语言的容器的学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-的容器"><a href="#C-的容器" class="headerlink" title="C++的容器"></a>C++的容器</h1><p>最近在做一些leetcode的题，有时选择了用C++来写，离不开一些C++容器的使用。于是总结一下C++容器。</p>
<h2 id="顺序性容器"><a href="#顺序性容器" class="headerlink" title="顺序性容器"></a>顺序性容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ol>
<li>vector是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢。</li>
<li>默认的构造函数是构造一个初始长度为0的内存空间，且分配的内存空间是以2的倍数动态增长的。</li>
<li>在push_back的过程中，若发现分配的内存空间不足，则重新分配一段连续的内存空间，其大小是现在连续空间的2倍，再将原先空间中的元素复制到新的空间中。</li>
<li>clear函数只是把vector的size清为零，但vector中的元素在内存中并没有消除，所以在使用vector的过程中会发现内存消耗会越来越多，导致内存泄露，现在经常用的方法是swap函数来进行解决。</li>
<li>利用swap函数，和临时对象交换，使V对象的内存为临时对象的内存，而临时对象的内存为V对象的内存。交换以后，临时对象消失，释放内存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V;</span><br><span class="line">V.push_back(<span class="number">1</span>); </span><br><span class="line">V.push_back(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(V); </span><br><span class="line"><span class="comment">//或者 V.swap(vector&lt;int&gt;());</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque支持双端插入数据。deque的内存空间分布是小片的连续，小片间用链表相连，实际上内部有一个map的指针。deque空间的重新分配要比vector快，重新分配空间后，原有的元素是不需要拷贝的。</p>
<p><img src="/images/my/container/00.png" alt=""></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>支持常数时间从容器任何位置插入和移除元素的容器。不支持快速随机访问。它通常实现为双向链表。</p>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map是一种关联容器，该容器用唯一的关键字来映射相应的值，即具有key-value功能。map内部自建一棵红黑树（一种自平衡二叉树），这棵树具有数据自动排序的功能，所以在map内部所有的数据都是有序的，以二叉树的形式进行组织。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ol>
<li>set同map一样，底层使用红黑树实现，插入删除操作时仅仅移动指针即可，不涉及内存的移动和拷贝，所以效率比较高。</li>
<li>set中的元素都是唯一的，而且默认情况下会对元素进行升序排列。</li>
</ol>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue是一个队列，实现先进先出功能。queue是在deque的基础上封装的。</p>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack是实现先进后出的功能，和queue一样，也是内部封装了deque。</p>
<h1 id="java的容器"><a href="#java的容器" class="headerlink" title="java的容器"></a>java的容器</h1><p>第一个图为简化图（其中粗线部分是重点的容器），第二个图为完整容器分类图</p>
<p><img src="/images/my/container/01.png" alt=""></p>
<p><img src="/images/my/container/02.png" alt=""></p>
<p><img src="/images/my/container/03.png" alt=""></p>
<h1 id="java的容器和kotlin容器的比较"><a href="#java的容器和kotlin容器的比较" class="headerlink" title="java的容器和kotlin容器的比较"></a>java的容器和kotlin容器的比较</h1><p><img src="/images/my/container/04.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/07/编程语言的容器的学习/" data-id="ck5fynb510026hes6ekf9gzss" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/容器/">容器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android中调用native的fork函数后的现象观察" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/android中调用native的fork函数后的现象观察/" class="article-date">
  <time datetime="2019-04-03T10:42:12.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/android中调用native的fork函数后的现象观察/">android中调用native的fork函数后的现象观察</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>android的app运行过程中，如果通过jni调用到了native层的fork()函数，那么java层的各对象都会复制一份吗？</p>
<h3 id="建工程做实验"><a href="#建工程做实验" class="headerlink" title="建工程做实验"></a>建工程做实验</h3><p>建立一个包含C++的android工程，在工程中的native-lib.cpp中改成这个<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jint JNICALL</span><br><span class="line">Java_mainpackage_MainActivity_invokeFork(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在kotlin中建立一个class<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainpackage</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeBody</span></span>(<span class="keyword">var</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(<span class="variable">$name</span> <span class="subst">$&#123;System.identityHashCode(this).toHex()&#125;</span>)"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">toHex</span><span class="params">()</span></span> = Integer.toHexString(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在MainActivity中写一个函数<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">studyFork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = SomeBody(<span class="string">"张三"</span>)</span><br><span class="line">    Log.i(<span class="string">"fork"</span>, <span class="string">"before fork &gt;&gt; sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span> forkRet = invokeFork()</span><br><span class="line">    Log.i(<span class="string">"fork"</span>, <span class="string">"after fork &gt;&gt; forkRet: <span class="variable">$forkRet</span> pid: <span class="subst">$&#123;Process.myPid()&#125;</span> sb: <span class="variable">$sb</span>"</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且在MainActivity被create之后，调用<code>studyFork()</code><br>发现输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before fork &gt;&gt; sb: (张三 3e8825b)</span><br><span class="line">after fork &gt;&gt; forkRet: 21281 pid: 21262 sb: (张三 3e8825b)</span><br><span class="line">after fork &gt;&gt; forkRet: 0 pid: 21281 sb: (张三 3e8825b)</span><br></pre></td></tr></table></figure></p>
<p>观察结果，得出自己的判断，对象sb在主进程和子进程中是同一个，即主进程和子进程共享同一个对象（后面的实验推翻了这个结论）。</p>
<h3 id="新的困惑"><a href="#新的困惑" class="headerlink" title="新的困惑"></a>新的困惑</h3><p>主进程和子进程共享虚拟机中同一个堆空间吗？两个进程操作这个对象，观察到的结果是什么呢？<br>继续做实验，修改了<code>studyFork()</code>函数如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">studyFork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = SomeBody(<span class="string">"张三"</span>)</span><br><span class="line"></span><br><span class="line">    Log.i(<span class="string">"fork"</span>, <span class="string">"before fork &gt;&gt; sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span> forkRet = invokeFork()</span><br><span class="line">    Log.i(<span class="string">"fork"</span>, <span class="string">"after fork &gt;&gt; forkRet: <span class="variable">$forkRet</span> pid: <span class="subst">$&#123;Process.myPid()&#125;</span> sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forkRet == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        sb.name = <span class="string">"李四"</span></span><br><span class="line">        Log.i(<span class="string">"fork"</span>, <span class="string">"sub process &gt;&gt; forRet: <span class="variable">$forkRet</span> modified-sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        Log.i(<span class="string">"fork"</span>, <span class="string">"parent process &gt;&gt; forRet: <span class="variable">$forkRet</span> sb: <span class="variable">$sb</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让子进程创建后立刻修改sb的name为“李四”，然后父进程1s之后观察这个sb并打印日志。日志如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-04-03 18:33:24.208  I/fork: before fork &gt;&gt; sb: (张三 3e8825b)</span><br><span class="line">2019-04-03 18:33:24.214  I/fork: after fork &gt;&gt; forkRet: 0 pid: 22143 sb: (张三 3e8825b)</span><br><span class="line">2019-04-03 18:33:24.214  I/fork: after fork &gt;&gt; forkRet: 22143 pid: 22123 sb: (张三 3e8825b)</span><br><span class="line">2019-04-03 18:33:24.215  I/fork: sub process &gt;&gt; forRet: 0 modified-sb: (李四 3e8825b)</span><br><span class="line">2019-04-03 18:33:25.219  I/fork: parent process &gt;&gt; forRet: 22143 sb: (张三 3e8825b)</span><br></pre></td></tr></table></figure></p>
<p>于是得出自己的判断：子进程修改了sb对象的name，主进程感知不到。进而得出这样的结论，主进程和子进程不共享同一个对象，只是各自持有一份sb拷贝。进而，两个进程不共享虚拟机的同一个堆空间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/03/android中调用native的fork函数后的现象观察/" data-id="ck5fynb520028hes6db9zhzrc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java类加载机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/java类加载机制/" class="article-date">
  <time datetime="2019-04-03T07:14:27.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/java类加载机制/">java类加载机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在看java和android的类加载机制，途中有一些疑惑，就先记下来。</p>
<h3 id="一些概念的理解"><a href="#一些概念的理解" class="headerlink" title="一些概念的理解"></a>一些概念的理解</h3><p><strong>jdk和jre是什么区别？</strong> JDK就是Java Development Kit.简单的说JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。</p>
<p><strong>rt.jar、dt.jar、tools.jar是什么？</strong> rt.jar这个文件是极为重要的一个文件，rt是runtime的缩写，即运行时的意思。是java程序在运行时必不可少的文件。里面包含了java程序员常用的包，如java.lang，java.util，java.io，java.net,java.applet等；dt.jar是关于运行环境的类库，主要是swing的包，你要用到swing时最好加上；tools.jar 是系统用来编译一个类的时候用到的，也就是javac的时候用到 。</p>
<p><strong><code>lib/</code>和<code>jre/lib</code>的区别是什么？</strong> JDK下的lib包括java开发环境的jar包，是给JDK用的，例如JDK下有一些工具，可能要用该目录中的文件。例如，编译器等；JDK下的JRE下的lib是开发环境中，运行时需要的jar包。最典型的就是导入的外部驱动jar包。</p>
<p><strong>什么是android dex文件</strong>  明白什么是 Dex 文件之前，要先了解一下 JVM，Dalvik 和 ART。JVM 是 JAVA 虚拟机，用来运行 JAVA 字节码程序。Dalvik 是 Google 设计的用于 Android平台的运行时环境，适合移动环境下内存和处理器速度有限的系统。ART 即 Android Runtime，是 Google 为了替换 Dalvik 设计的新 Android 运行时环境，在Android 4.4推出。ART 比 Dalvik 的性能更好。Android 程序一般使用 Java 语言开发，但是 Dalvik 虚拟机并不支持直接执行 JAVA 字节码，所以会对编译生成的 .class 文件进行翻译、重构、解释、压缩等处理，这个处理过程是由 dx 进行处理，处理完成后生成的产物会以 .dex 结尾，称为 Dex 文件。Dex 文件格式是专为 Dalvik 设计的一种压缩格式。所以可以简单的理解为：Dex 文件是很多 .class 文件处理后的产物，最终可以在 Android 运行时环境执行。</p>
<h3 id="jvm中的类加载器"><a href="#jvm中的类加载器" class="headerlink" title="jvm中的类加载器"></a>jvm中的类加载器</h3><h4 id="启动类加载器（Bootstrap-Class-Loader）"><a href="#启动类加载器（Bootstrap-Class-Loader）" class="headerlink" title="启动类加载器（Bootstrap Class Loader）"></a>启动类加载器（Bootstrap Class Loader）</h4><p>主要负责加载jdk中的核心类库，比如rt.jar和其它在jre/lib中的核心类。Bootstrap Class Loader是所有classloader的父加载器。它是有native代码实现的</p>
<blockquote>
<p>It’s mainly responsible for loading JDK internal classes, typically rt.jar and other core libraries located in $JAVA_HOME/jre/lib directory. Additionally, Bootstrap class loader serves as a parent of all the other ClassLoader instances.</p>
<p>This bootstrap class loader is part of the core JVM and is written in native code. Different platforms might have different implementations of this particular class loader.</p>
</blockquote>
<h4 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h4><p>扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的，它负责将 <code>&lt;JAVA_HOME &gt;/lib/ext</code>或者由系统变量<code>-Djava.ext.dir</code>指定位置中的类库 加载到内存中。开发者可以直接使用标准扩展类加载器。</p>
<h4 id="系统类加载器（System-Class-Loader）"><a href="#系统类加载器（System-Class-Loader）" class="headerlink" title="系统类加载器（System Class Loader）"></a>系统类加载器（System Class Loader）</h4><p>系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的，它负责将用户类路径(java -classpath或-Djava.class.path变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，加载到内存中。开发者可以直接使用系统类加载器。</p>
<blockquote>
<p> The system or application class loader, on the other hand, takes care of loading all the application level classes into the JVM. It loads files found in the classpath environment variable, -classpath or -cp command line option. Also, it’s a child of Extensions classloader.</p>
</blockquote>
<blockquote>
<p> The extension class loader is a child of the bootstrap class loader and takes care of loading the extensions of the standard core Java classes so that it’s available to all applications running on the platform.</p>
<p>Extension class loader loads from the JDK extensions directory, usually $JAVA_HOME/lib/ext directory or any other directory mentioned in the java.ext.dirs system property.</p>
</blockquote>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClassLoaders</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">"Classloader of this class:"</span></span><br><span class="line">        + PrintClassLoader.class.getClassLoader());</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">"Classloader of Logging:"</span></span><br><span class="line">        + Logging.class.getClassLoader());</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">"Classloader of ArrayList:"</span></span><br><span class="line">        + ArrayList.class.getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是</p>
<blockquote>
<p>Class loader of this class:sun.misc.Launcher$AppClassLoader@18b4aac2<br>Class loader of Logging:sun.misc.Launcher$ExtClassLoader@3caeaf62<br>Class loader of ArrayList:null</p>
</blockquote>
<h3 id="classloader的类的继承关系"><a href="#classloader的类的继承关系" class="headerlink" title="classloader的类的继承关系"></a>classloader的类的继承关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Object &lt;|-- ClassLoader</span><br><span class="line">ClassLoader &lt;|-- SecureClassLoader</span><br><span class="line">SecureClassLoader &lt;|-- URLClassLoader</span><br><span class="line">URLClassLoader &lt;|-- ExtClassLoader</span><br><span class="line">URLClassLoader &lt;|-- AppClassLoader</span><br><span class="line">BootStrapClassLoader &lt;-- ExtClassLoader</span><br><span class="line">ExtClassLoader &lt;-- AppClassLoader</span><br><span class="line">AppClassLoader &lt;-- ClassLoaderA</span><br><span class="line">AppClassLoader &lt;-- ClassLoaderB</span><br></pre></td></tr></table></figure>
<p><img src="/images/my/classloader01.png" alt="classloader01"><br>其中，ExtClassLoader属于Extension Class Loader，AppClassLoader属于System Class Loader。</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>JVM在加载类时默认采用的是双亲委派机制。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归 (本质上就是loadClass函数的递归调用)。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。如果父类加载器可以完成这个类加载请求，就成功返回；只有当父类加载器无法完成此加载请求时，子加载器才会尝试自己去加载。事实上，大多数情况下，越基础的类由越上层的加载器进行加载。</p>
<p>加载过程如下：</p>
<ol>
<li>源 ClassLoader 先判断该 Class 是否已加载，如果已加载，则直接返回 Class，如果没有则委托给父类加载器。</li>
<li>父类加载器判断是否加载过该 Class，如果已加载，则直接返回 Class，如果没有则委托给祖父类加载器。</li>
<li>依此类推，直到始祖类加载器（引用类加载器）。</li>
<li>始祖类加载器判断是否加载过该 Class，如果已加载，则直接返回 Class，如果没有则尝试从其对应的类路径下寻找 class 字节码文件并载入。如果载入成功，则直接返回 Class，如果载入失败，则委托给始祖类加载器的子类加载器。</li>
<li>始祖类加载器的子类加载器尝试从其对应的类路径下寻找 class 字节码文件并载入。如果载入成功，则直接返回 Class，如果载入失败，则委托给始祖类加载器的孙类加载器。</li>
<li>依此类推，直到源 ClassLoader。</li>
<li>源 ClassLoader 尝试从其对应的类路径下寻找 class 字节码文件并载入。如果载入成功，则直接返回 Class，如果载入失败，源 ClassLoader 不会再委托其子类加载器，而是抛出异常。</li>
</ol>
<h3 id="android的class-loader"><a href="#android的class-loader" class="headerlink" title="android的class loader"></a>android的class loader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Object &lt;|-- ClassLoader</span><br><span class="line">ClassLoader &lt;|-- BaseDexClassLoader</span><br><span class="line">ClassLoader &lt;|-- SecureClassLoader</span><br><span class="line">SecureClassLoader &lt;|-- URLClassLoader</span><br><span class="line">BaseDexClassLoader &lt;|-- PathClassLoader</span><br><span class="line">BaseDexClassLoader &lt;|-- DexClassLoader</span><br><span class="line">BaseDexClassLoader &lt;|-- InMemoryDexClassLoader</span><br><span class="line">ClassLoader &lt;|-- BootClassLoader</span><br><span class="line">BootClassLoader &lt;-- PathClassLoader</span><br></pre></td></tr></table></figure>
<p><img src="/images/my/classloader02.png" alt="classloader02"><br>几个知识点</p>
<ol>
<li>在 Android 中，App 安装到手机后，apk 里面的 class.dex 中的 class 均是通过 PathClassLoader 来加载的。</li>
<li>对比 PathClassLoader 只能加载已经安装应用的 dex 或 apk 文件，DexClassLoader 则没有此限制，可以从 SD 卡上加载包含 class.dex 的 .jar 和 .apk 文件，这也是插件化和热修复的基础，在不需要安装应用的情况下，完成需要使用的 dex 的加载。<code>A class loader that loads classes from .jar and .apk filescontaining a classes.dex entry. This can be used to execute code notinstalled as part of an application.</code></li>
<li>SecureClassLoader和URLClassLoader和JDK8中的是一样的</li>
<li>InMemoryDexClassLoader是Android8.0新增的类加载器，继承自BaseDexClassLoader，用于加载内存中的dex文件。</li>
<li>BootClassLoader是在Zygote进程的入口方法中创建的，PathClassLoader则是在Zygote进程创建SystemServer进程时创建的。</li>
</ol>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>SystemServer进程中创建了PathClassLoader，Zygote进程中创建了BootClassLoader，因为app进程是靠Zygote进程fork出来的，那么app进程中的PathClassLoader是在哪里创建的？</p>
<p>SystemServer进程中创建了PathClassLoader，Zygote进程中创建了BootClassLoader，因为app进程是靠Zygote进程fork出来的，那么app进程中的PathClassLoader是在哪里创建的？</p>
<p>于是带着这个问题又研究了一下android api-level 为28的源代码，把app中的PathClassLoader的创建过程用时序图描述出来。<br><img src="/images/my/pathclassloader_create.png" alt=""></p>
<p>在ActivityThread中ApplicationThread的bindApplication方法中发送消息BIND_APPLICATION给H，H也是ActivityThread的内部类，它继承了Handler，然后H调用ActivityThread的handleBindApplicationf方法，然后ActivityThread处理该消息时经过层层调用，最后返回了PathClassLoader。</p>
<p>那么ActivityThread中的ApplicationThread的bindApplication是在什么时候被谁调用的呢？调用关系如下描述：<br><img src="/images/my/bindapp.png" alt=""></p>
<p>可以看到ActivityThread有个静态main方法，它经过层层调用并且经过IActivityManager这个IPC操作，调用到了AMS的一些方法，然后AMS再经过IApplicationThread这个IPC操作，调用到了ActivityThread的ApplicationThread的bindApplication方法。</p>
<p>IActivityManager对应的是AMS，IApplicationThread对应的是ActivityThread的ApplicationThread。</p>
<p>ActivityThread的这个静态main方法是Zygote fork出来app这个子进程后，子进程调用到的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/72217806" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/72217806</a></li>
<li><a href="https://www.baeldung.com/java-classloaders" target="_blank" rel="noopener">https://www.baeldung.com/java-classloaders</a></li>
<li><a href="https://jaeger.itscoder.com/android/2016/08/27/android-classloader.html" target="_blank" rel="noopener">https://jaeger.itscoder.com/android/2016/08/27/android-classloader.html</a></li>
<li><a href="https://juejin.im/post/5bf22bb5e51d454cdc56cbd5" target="_blank" rel="noopener">https://juejin.im/post/5bf22bb5e51d454cdc56cbd5</a></li>
<li><a href="https://www.jianshu.com/p/a1f40b39b3de" target="_blank" rel="noopener">https://www.jianshu.com/p/a1f40b39b3de</a></li>
<li><a href="https://www.jianshu.com/p/fbea00880da1" target="_blank" rel="noopener">https://www.jianshu.com/p/fbea00880da1</a></li>
<li><a href="https://www.zhihu.com/question/50828920" target="_blank" rel="noopener">https://www.zhihu.com/question/50828920</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/03/java类加载机制/" data-id="ck5fynb71003khes6cjo75c9l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-对java虚拟机垃圾回收的学习的总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/对java虚拟机垃圾回收的学习的总结/" class="article-date">
  <time datetime="2019-03-24T13:00:44.000Z" itemprop="datePublished">2019-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/对java虚拟机垃圾回收的学习的总结/">对java虚拟机垃圾回收的学习的总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java垃圾回收机制是对无用信息对象进行检索，并且回收它们所占用的内存空间，使该部分空间可被再次使用。垃圾回收是不定时的发生。</p>
<h1 id="判断对象是否为垃圾的算法"><a href="#判断对象是否为垃圾的算法" class="headerlink" title="判断对象是否为垃圾的算法"></a>判断对象是否为垃圾的算法</h1><p>垃圾回收算法包含引用计数算法（Reference Counting Collector）、根搜索算法（Tracing Collector）</p>
<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>堆中每个对象都对应一个引用计数器。</p>
<ul>
<li>当该对象被创建后首次赋值时，该引用值设置为1。</li>
<li>一个新的地方要引用该对象时，引用值加1。</li>
<li>当该对象的一个引用值被置为null或者超过了其生命周期或者引用别的对象时，引用值减1。</li>
<li>当一个对象对应的引用值为0时，它将被等待回收。当它被回收后，它所引用的对象的引用计数器值都减1。</li>
</ul>
<p>它的优缺点如下：</p>
<ol>
<li>优点是速度快，可以在不打断程序运行的情况下交至运行，判断效率高；</li>
<li>缺点是难以检测出循环引用的对象。引用计数器增加程序运行的开销。</li>
</ol>
<h2 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h2><p>从一系列GC Root出发，来对引用节点进行遍历，凡是不可到达的对象（它和GC Root没有任何引用链）都是无用信息对象，标记它们使之等待回收。</p>
<p>GC根对象包含如下：</p>
<ul>
<li>虚拟机栈中的引用对象（栈帧中的引用变量表）</li>
<li>方法区的类的静态属性引用的对象</li>
<li>方法区的常量引用的对象（这个还不没搞清楚，后续继续分析..）</li>
<li>本地方法栈中引用的对象（这个还不没搞清楚，后续继续分析..）</li>
<li>活跃线程</li>
</ul>
<p>该算法是从离散数学的图论引入的。</p>
<p><img src="/images/my/1.webp" alt=""></p>
<h2 id="标记回收对象的关键点分析"><a href="#标记回收对象的关键点分析" class="headerlink" title="标记回收对象的关键点分析"></a>标记回收对象的关键点分析</h2><p>当判断是否为回收对象的算法开始运行时，如果此时采用的是根搜索算法，java程序将会被暂停（Stop the world， STW），这个情况被称为安全点（Safe Point）。在把查找到的无用信息对象进行回收之前，如果检测到部分对象重写了finalize方法并且还没有被执行过，则把这部分对象保存到一个F-Queue中。然后在一低优先级的线程中对该队列中的对象进行遍历来执行它们的finalize。此时若出现这种情况，一个对象的finalize方法被执行时，把该对象重新和引用链上某一对象建立关联，那么这个对象将通过这种自救的方式避免被回收。不然的话，它将被回收掉。</p>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="Tracing算法（Tracing-Collector）-或-标记—清除算法"><a href="#Tracing算法（Tracing-Collector）-或-标记—清除算法" class="headerlink" title="Tracing算法（Tracing Collector） 或 标记—清除算法"></a>Tracing算法（Tracing Collector） 或 标记—清除算法</h2><p>对象被标记后将被回收，回收后会留下来内存碎片。未被标记的活动对象将不受影响。但是要额外维护一个空闲列表来记录空闲区域和大小，而且产生的内存碎片会妨碍后续的内存分配。</p>
<p><img src="/images/my/2.webp" alt=""></p>
<h2 id="Compacting算法（Compacting-Collector）-或-标记—整理算法"><a href="#Compacting算法（Compacting-Collector）-或-标记—整理算法" class="headerlink" title="Compacting算法（Compacting Collector） 或 标记—整理算法"></a>Compacting算法（Compacting Collector） 或 标记—整理算法</h2><p>对象被标记后不是被清除掉，而是把所有未标记的活动对象向内存中的一端进行移动，端边界以外的内存将被清理掉，避免内存碎片。但是移动对象和更新引用地址将会导致GC增加执行时间。</p>
<p><img src="/images/my/3.webp" alt=""></p>
<h2 id="Copying算法（Copying-Collector）"><a href="#Copying算法（Copying-Collector）" class="headerlink" title="Copying算法（Copying Collector）"></a>Copying算法（Copying Collector）</h2><p>建立两个面（对象面、空闲面），当对象面内存用完时，就把活动对象都copy到空闲面上，然后清理原来对象面的内存，把它变成新的空闲面，然后原来的空闲面变为新的对象面。</p>
<p>它有很多优点，比如标记阶段和copy阶段可以同时进行，只移动栈顶指针的位置即可，每次只copy一次内存所以高效，避免内存碎片。但是需要额外的一份相同大小的内存，所以整体上一次性分配的内存缩小了一半。</p>
<p><img src="/images/my/4.webp" alt=""></p>
<h2 id="Adaptive算法（Adaptive-Collector）"><a href="#Adaptive算法（Adaptive-Collector）" class="headerlink" title="Adaptive算法（Adaptive Collector）"></a>Adaptive算法（Adaptive Collector）</h2><p>根据当前堆的使用情况来分析要采用哪种垃圾收集器算法</p>
<h1 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h1><p>java堆基于Generation算法（Generational Collector）划分为新生代、年老代，持久代。这个划分主要基于一个事实：不同的对象具有不同的生命周期。不同的代存储不同生命周期的对象，采用的垃圾回收算法也不同。</p>
<p><img src="/images/my/5.webp" alt=""></p>
<h2 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h2><p>新创建的对象都将放到新生代内存中，新生代内存包含eden区和survivor区，survivor区又将包含survivor0和survivor1两个区。新创建的对象都将放入到eden区，若eden区满了之后，则把对象copy到survivor0区，若survivor0区也满了，就把对象copy到survivor1区，此时survivor1区变为新的survivor0，原来的survivor0变为新的survivor1。若对象在survivor区存活时间比较久，则该对象讲移入到年老代内存中。</p>
<h2 id="年老代（Old-Generation）"><a href="#年老代（Old-Generation）" class="headerlink" title="年老代（Old Generation）"></a>年老代（Old Generation）</h2><p>年老代的堆主要存储生命期长的对象和一些占用大内存的对象。当在新生代中的survivor的对象躲过一次GC，其年龄加1岁，若年龄增加到15岁，则该对象从新生代转移到年老代。</p>
<h2 id="持久代（Permanent-Generation）"><a href="#持久代（Permanent-Generation）" class="headerlink" title="持久代（Permanent Generation）"></a>持久代（Permanent Generation）</h2><p>持久代的堆主要存储静态文件（类和方法）和常量。在java8中采用了元空间（MetaSpace）取代了持久代。</p>
<h1 id="android垃圾回收所采用的算法"><a href="#android垃圾回收所采用的算法" class="headerlink" title="android垃圾回收所采用的算法"></a>android垃圾回收所采用的算法</h1><blockquote>
<p>待续</p>
</blockquote>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><ul>
<li><strong>虚引用</strong>为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。那么这是如何做到的呢？</li>
<li>离散数学的图论</li>
<li>指针碰撞（Pointer Bumping）是什么</li>
<li>java回收中提到的句柄是什么</li>
<li>新生代内存为什么是按照8:1:1，具体机制是什么</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/24/对java虚拟机垃圾回收的学习的总结/" data-id="ck5fynb4z0023hes6vosofhlj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android消息机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/android消息机制/" class="article-date">
  <time datetime="2019-03-24T12:48:21.000Z" itemprop="datePublished">2019-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/android消息机制/">android消息机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="消息机制相关类的介绍"><a href="#消息机制相关类的介绍" class="headerlink" title="消息机制相关类的介绍"></a>消息机制相关类的介绍</h1><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler作为一个消息处理的类，负责消息的发送和消息的执行，消息的发送又包含即时的和延时的。应用场景包含多线程间通信。Handler的运转以及要支持多线程间通信，还需要Looper类。</p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>Looper主要从列表中获取消息，并且处理消息。Looper提供了一些静态方法（prepare()、myLooper()、myQueue()、loop()等）,这些静态方法都使用了一个静态成员sThreadLocal（ThreadLocal类），sThreadLocal存储了与线程对应的Looper的对象。Looper类中组合了一个MessageQueue类。而Looper取消息的来源正是MessageQueue。</p>
<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MesssageQueue类中维护一个消息队列（由链表实现），MessageQueue不仅组合在Looper中，也聚合在Handler中。它向Handler提供了把消息入队列的接口，向Looper提供了把消息从队列取出的接口。</p>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread is-a Thread，并且主要职责是在run方法中创建Looper对象和执行Looper的loop循环(通过调用Looper的静态方法)。这样就可以想象一个多线程的环境下，线程A通过Handler发送消息，Handler把消息传给MessageQueue入队列；线程B通过Looper的loop循环，从MessageQueue中取出并处理该消息。</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>上面一直提的消息，其实是Message类，它里边包含了消息值（what），以及其它一些消息信息（arg1、arg2、obj）。Message类中的字段next，是为了实现MessageQueue中的消息链表。Message类中target字段是Handler类，引用了外层的Handler对象，它的作用是，当Looper取出消息后，要处理它，其实就是调用消息中的target的dispatchMessage方法。如下代码，摘自于Looper的静态方法loop中的一处处理消息的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> start = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    msg.target.dispatchMessage(msg);</span><br><span class="line">    end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">        Trace.traceEnd(traceTag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h1><p>为了方便理解，用StarUML设计了一张类图和一张时序图。</p>
<p><img src="/images/my/xiaoxijizhi01.jpg" alt="xiaoxi01"></p>
<p><img src="/images/my/xiaoxijizhi02.jpg" alt="xiaoxi02"></p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>关于epoll的介绍，可以看这里<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a></p>
<h2 id="inativePollOnce"><a href="#inativePollOnce" class="headerlink" title="inativePollOnce"></a>inativePollOnce</h2><h2 id="nativeWake"><a href="#nativeWake" class="headerlink" title="nativeWake"></a>nativeWake</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/24/android消息机制/" data-id="ck5fynb4w001zhes6vnr04rdo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c-c-学习笔记/">c/c++学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/emacs/">emacs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java和kotlin/">java和kotlin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活感悟/">生活感悟</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/程序人生/">程序人生</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/common-lisp/">common lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/emacs/">emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eql/">eql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/equal/">equal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idea/">idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jsp/">jsp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin/">kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/let/">let</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lisp/">lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setq/">setq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/">synchronized</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/指南/">指南</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/目标/">目标</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/c/" style="font-size: 12px;">c</a> <a href="/tags/c/" style="font-size: 14px;">c++</a> <a href="/tags/common-lisp/" style="font-size: 10px;">common lisp</a> <a href="/tags/emacs/" style="font-size: 12px;">emacs</a> <a href="/tags/eql/" style="font-size: 10px;">eql</a> <a href="/tags/equal/" style="font-size: 10px;">equal</a> <a href="/tags/idea/" style="font-size: 10px;">idea</a> <a href="/tags/java/" style="font-size: 18px;">java</a> <a href="/tags/jsp/" style="font-size: 10px;">jsp</a> <a href="/tags/kotlin/" style="font-size: 16px;">kotlin</a> <a href="/tags/let/" style="font-size: 10px;">let</a> <a href="/tags/lisp/" style="font-size: 10px;">lisp</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/setq/" style="font-size: 10px;">setq</a> <a href="/tags/synchronized/" style="font-size: 10px;">synchronized</a> <a href="/tags/thread/" style="font-size: 10px;">thread</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/指南/" style="font-size: 10px;">指南</a> <a href="/tags/目标/" style="font-size: 10px;">目标</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/15/关于android异步编程的学习/">关于android异步编程的学习</a>
          </li>
        
          <li>
            <a href="/2020/01/15/关于kotlin的几个扩展函数-run-apply-let-with-also/">关于kotlin的几个扩展函数(run, apply, let, with, also)</a>
          </li>
        
          <li>
            <a href="/2019/10/25/kotlin中链式调用的简单思考/">kotlin中链式调用的简单思考</a>
          </li>
        
          <li>
            <a href="/2019/05/23/android输入法机制的学习总结/">android输入法机制的学习总结</a>
          </li>
        
          <li>
            <a href="/2019/05/16/对java的class文件的字节码的分析/">对java的class文件的字节码的分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 sunhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>