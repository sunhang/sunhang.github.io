<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>对kotlin和java中的synchronized的浅谈</title></head><body>　　<div class="inner"><h2>对kotlin和java中的synchronized的浅谈</h2><p>synchronized在java中是一个关键字，但是在kotlin中是一个内联函数。假如分别在java和kotlin代码锁住同一个对象，会发生什么呢，今天写了代码试了试。<br>首先定义people类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(<span class="string">"在%s线程中吃第%d个包子"</span>, Thread.currentThread().getName(), i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后定义一个java类开启一个线程并且锁住people<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJavaClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> People people;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyJavaClass</span><span class="params">(People people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.people = people;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (people) &#123;</span><br><span class="line">                    people.doSomething();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"java"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再定义一个kotlin类开启一个线程并且锁住相同的people<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyKotlinClass</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> people: People) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Thread(Runnable &#123;</span><br><span class="line">            synchronized(people) &#123;</span><br><span class="line">                people.doSomething()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"kotlin"</span>).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在main函数中执行如下代码<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> people = People()</span><br><span class="line"></span><br><span class="line">    MyJavaClass(people).startThread()</span><br><span class="line">    MyKotlinClass(people).startThread()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>观察输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">在java线程中吃第0个包子</span><br><span class="line">在java线程中吃第1个包子</span><br><span class="line">在java线程中吃第2个包子</span><br><span class="line">在java线程中吃第3个包子</span><br><span class="line">在java线程中吃第4个包子</span><br><span class="line">在java线程中吃第5个包子</span><br><span class="line">在java线程中吃第6个包子</span><br><span class="line">在java线程中吃第7个包子</span><br><span class="line">在java线程中吃第8个包子</span><br><span class="line">在java线程中吃第9个包子</span><br><span class="line">在kotlin线程中吃第0个包子</span><br><span class="line">在kotlin线程中吃第1个包子</span><br><span class="line">在kotlin线程中吃第2个包子</span><br><span class="line">在kotlin线程中吃第3个包子</span><br><span class="line">在kotlin线程中吃第4个包子</span><br><span class="line">在kotlin线程中吃第5个包子</span><br><span class="line">在kotlin线程中吃第6个包子</span><br><span class="line">在kotlin线程中吃第7个包子</span><br><span class="line">在kotlin线程中吃第8个包子</span><br><span class="line">在kotlin线程中吃第9个包子</span><br></pre></td></tr></table></figure></p>
<p>根据结果可以看到java和kotlin在锁住一个对象时可以做到互斥。但是java中的synchronized是个关键字，kotlin中synchronized是个函数，那么它们为什么做到互斥的呢？<br>java中synchronized的底层实现这这篇文章中描述的比较清楚<a href="https://blog.csdn.net/hbtj_1216/article/details/77773292" target="_blank" rel="noopener">https://blog.csdn.net/hbtj_1216/article/details/77773292</a>，关键字synchronized被编译成了monitorenter和monitorexit。再看kotlin中的synchronized函数<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">synchronized</span><span class="params">(lock: <span class="type">Any</span>, block: ()</span></span> -&gt; R): R &#123;</span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">"NON_PUBLIC_CALL_FROM_PUBLIC_INLINE"</span>, <span class="meta-string">"INVISIBLE_MEMBER"</span>)</span></span><br><span class="line">    monitorEnter(lock)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> block()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="meta">@Suppress(<span class="meta-string">"NON_PUBLIC_CALL_FROM_PUBLIC_INLINE"</span>, <span class="meta-string">"INVISIBLE_MEMBER"</span>)</span></span><br><span class="line">        monitorExit(lock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里边也是有monitorEnter和monitorExit的，所以做出推测，不管synchronized是java中的关键字还是kotlin中的函数，最终被编译成的字节码是一样。</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>